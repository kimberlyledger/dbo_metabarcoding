---
title: "chukchi catch"
output: html_document
date: "2024-10-22"
---

updated 10/29/24 - using new BASIS data export from Andrew Diamond 
updated again 11/1/23 - using newer version on BASIS export (needed to add beam trawls to be able to match genetic data from 2017/2019) and now genetic data has station and event IDs
updated 11/4/23 - was missing life history stage column in 11/1 export. but this one is now missing ctd variables 

```{r}
library(tidyverse)
library(taxize)
library(ggplot2)
library(viridis)
```


read in BASIS catch data from >60N in years of Integrated Arctic Surveys
```{r}
chukchi_catch <- read.csv("/home/kimberly.ledger/dbo_metabarcoding/data/Kim_Arctic_11.4.24.csv") %>%
  filter(!StationID %in% c("20171602001", "20171602002", "20171602003"))  # remove three NBS stations below 60N that were included in data export

# what unique cruises are in this data and how many station did each sample? 
chukchi_catch %>%
  separate(StationID, into = c("year_vessel_cruise", "station"), sep = 8, remove = F) %>%
  group_by(year_vessel_cruise) %>%
  summarize(n_stations = n_distinct(station))
```

get full taxonomic info for the taxa caught
```{r}
# taxa list for this catch data 
taxa_list <- unique(chukchi_catch$ScientificName)

# look up the tsn codes of basis surveys  
tsn_codes <- httr::content(
    httr::GET('https://apex.psmfc.org/akfin/data_marts/akmp/basis_tsn'),
    type = "application/json") %>%
  bind_rows() %>%
  rename_with(tolower) %>%
  dplyr::rename(speciestsn = tsn) %>%
  select(speciestsn, commonname, scientificname) %>%
  filter(scientificname %in% taxa_list)

full_classification <- classification(tsn_codes$speciestsn, db = "itis")

# Remove any NULL or empty results from the list
full_classification_clean <- full_classification  %>%
  keep(~ !is.null(.) && is.data.frame(.) && nrow(.) > 0)

# Convert the list of taxonomies into a dataframe
taxonomy_df <- full_classification_clean %>%
  bind_rows(.id = "speciestsn") %>%
  select(!id) %>%
  pivot_wider(names_from = rank, values_from = name) %>%
  select(speciestsn, class, order, family, genus, species) %>%
  filter(speciestsn != 171582) #remove duplicate entry

# join to my taxa list 
taxa_df <- tsn_codes %>%
  left_join(taxonomy_df, by = "speciestsn")

# i am going to filter by class == "Teleostei" since that's what the MiFish primer's target, do any of the entries with class == NA need to stay? 
taxa_na <- taxa_df %>%
  filter(is.na(class))
taxa_na
```

okay, so sturgeon poacher's scientific name is misspelled 
```{r}
missing_taxa <- data.frame(matrix(ncol = ncol(taxa_na), nrow = 6))
colnames(missing_taxa) <- colnames(taxa_na)

missing_taxa$speciestsn <- c("167481", "171582", "171584", "171587", "167281", "167373")
missing_taxa$commonname <- c("Sturgeon Poacher", "Slender eelblenny", "Daubed shanny", "Stout eelblenny", "Butterfly sculpin", "Ribbed Sculpin")
missing_taxa$scientificname <- c("Podothecus acipenserinus", "Lumpenus fabricii", "Lumpenus maculatus", "Lumpenus medius", "Hemilepidotus papilio", "Triglops pingeli")
missing_taxa$class <- c("Teleostei", "Teleostei", "Teleostei", "Teleostei", "Teleostei", "Teleostei") 
missing_taxa$order <- c("Perciformes", "Perciformes", "Perciformes", "Perciformes", "Perciformes", "Perciformes")
missing_taxa$family <- c("Agonidae", "Lumpenidae", "Lumpenidae", "Lumpenidae", "Cottidae", "Cottidae")
missing_taxa$genus <- c("Podothecus", "Lumpenus", "Lumpenus", "Lumpenus", "Hemilepidotus", "Triglops")
missing_taxa$species <- c("Podothecus acipenserinus", "Lumpenus fabricii", "Lumpenus maculatus", "Lumpenus medius", "Hemilepidotus papilio", "Triglops pingeli")

# Update `taxa_df` with values from `missing_taxa` for matching `speciestsn`
updated_taxa_df <- taxa_df %>%
  rows_update(missing_taxa, by = "speciestsn")

updated_taxa_df %>%
  filter(is.na(class))
```

join full taxonomic information to the catch data and filter to just retain the fish 
```{r}
fish_catch <- chukchi_catch %>%
  dplyr::rename(commonname = "CommonName") %>%
  dplyr::rename(scientificname = "ScientificName") %>%
  left_join(updated_taxa_df) %>%
  filter(class == "Teleostei")
```

how many taxa are identified to the species level, and if not, what are the IDs? 
```{r}
fish_catch %>%
  filter(scientificname == species) %>%
  select(commonname, scientificname) %>%
  unique()

fish_catch %>%
  filter(scientificname != species | is.na(species) | is.na(genus) | is.na(family) | is.na(order)) %>%
  select(commonname, scientificname, species) %>%
  unique()
```

okay, let's make a taxon column that's analogous to the eDNA mb data that is the lowest taxonomic resolution ID 

```{r}
fish_catch <- fish_catch %>%
  mutate(taxon = ifelse(scientificname == species, species, NA),
         taxon = ifelse(scientificname == "Osmerus mordax dentex", species, taxon),
         taxon = ifelse(scientificname == "Clupea pallasi", species, taxon),
         taxon = ifelse(scientificname == "Lumpenus maculatus", species, taxon),
         taxon = ifelse(scientificname == "Myoxocephalus scorpiodes", species, taxon),
         taxon = ifelse(scientificname == "Eumesogrammus preacisus", species, taxon))

fish_catch <- fish_catch %>%
  mutate(taxon = ifelse(is.na(taxon) & !is.na(genus), genus, taxon)) %>%
  mutate(taxon = ifelse(is.na(taxon) & !is.na(family), family, taxon)) %>%
  filter(!is.na(taxon))  #this removes just a few unidentified fish and flatfish 

fish_catch %>%
  select(commonname, scientificname, order, family, genus, species, taxon) %>%
  unique()  
```

hooray! taxon ids are looking good, but let's verify that all the species are known to occur in the North Pacific and/or Pacific Arctic. i'm not going to worry about taxa that are above species level... 

```{r}
library(rfishbase)

#one-time download of all fishbase tables... this takes a bit 
#fb_import()

spp_list <- unique(fish_catch$species)

#first, validate species names using rfishbase synonyms
spp_df <- synonyms(spp_list)

#first use synonym column 

#get distribution info 
spp_distribution <- distribution(spp_df$Species) %>%
  select(Species, FAO) %>%
  unique()

#add column to designate if we will consider a species as "in range"- for this study, this will be NE Pacific and Arctic Ocean 
spp_distribution_range <- spp_distribution %>%
  mutate(in_range = ifelse(is.na(FAO), NA, "no"),
         in_range = ifelse(FAO == "Pacific, Northeast", "yes", in_range),
         in_range = ifelse(FAO == "Arctic Ocean", "yes", in_range))

#keep just a list of spp names and yes/no/NA for "in range"  - this way we can keep track of what spp didn't have any reference information in fishbase to determine range 
spp_range <- spp_distribution_range %>%
  select(Species, in_range) %>%
  unique() %>%
  filter(!is.na(Species))

# Find species with "no" in_range but no "yes" for the same species
no_without_yes <- spp_range %>%
  group_by(Species) %>%
  filter(all(in_range == "no")) %>%
  distinct(Species)

# check that none of these species known as Atlantic Arctic Species 
atlantic_arctic_spp <- read.csv("/home/kimberly.ledger/BeringSea_Arctic_eDNA/data/AtlanticArctic_SpeciesList.csv")

spp_df %>%
  filter(Species %in% atlantic_arctic_spp$Name)
```

cool, cool taxonomy looks good to go 

let's make a quick summary table of the fish catch 
```{r}
fish_catch %>%
  separate(StationID, into = c("year_vessel_cruise", "station"), sep = 8, remove = F) %>%
  group_by(year_vessel_cruise, taxon) %>%
  summarize(sum_TotalCatchNum = sum(TotalCatchNum),
            sum_TotalCatchWt = sum(TotalCatchWt))
```

what gear type was used in each of the years and what gear type caught the most fish and specifically the most gadids? 
- note that 2019 bottom trawl catch is not in the database 

```{r}
fish_catch %>%
  group_by(SampleYear, TowType) %>%
  summarize(catchwt = sum(TotalCatchWt),
            catchnum = sum(TotalCatchNum, na.rm = T)) 

fish_catch %>%
  filter(family == "Gadidae") %>%
  group_by(SampleYear, TowType) %>%
  summarize(catchwt = sum(TotalCatchWt),
            catchnum = sum(TotalCatchNum, na.rm = T)) 
```

okay, for 2017 and 2019 I am just going to use Midwater trawl catch data (most fish overall and gadids) 
for 2012 and 2013, i'll use both midwater and surface trawl data (i think since both have lots of fish and gadids)

let me remove the 2017 bottom and surface trawl data, and the 2019 surface trawl data 
```{r}
fish_catch_filtered <- fish_catch %>%
  filter(!(SampleYear == 2017 & TowType == "Bottom"),
         !(SampleYear == 2017 & TowType == "Surface"),
         !(SampleYear == 2019 & TowType == "Surface"))
```


alright, now since i know that the field IDs of 2017 and 2017 gadids were not great, I will reassign age-0 gadids based on the genetic ID proportions
- i'm only going to adjust field IDs of the arctic cod and pollock (small number of saffron cod and pacific cod were id'd in the field but it's not clear that those individuals were part of the specimens included in genetics IDs)

```{r}
gadid_age0 <- fish_catch_filtered %>%
  filter(SampleYear %in% c(2017, 2019)) %>%
  #filter(family == "Gadidae") %>%
  filter(taxon == "Boreogadus saida" | taxon == "Gadus chalcogrammus") %>%
  filter(LHSCode == "A0") %>% 
  group_by(StationID, EventCode, SampleYear, EQ.Latitude, EQ.Longitude, TowType) %>%
  summarise(n_catch = sum(TotalCatchNum),
            total_wt = sum(TotalCatchWt),
            ind_wt = total_wt/n_catch) %>%
  mutate(StationID = as.numeric(StationID)) %>%
  mutate(EventCode = as.numeric(EventCode))

gadid_age0_by_fieldID <- fish_catch_filtered %>%
  filter(SampleYear %in% c(2017, 2019)) %>%
  filter(taxon == "Boreogadus saida" | taxon == "Gadus chalcogrammus") %>%
  #filter(family == "Gadidae") %>%           
  filter(LHSCode == "A0") %>%
  group_by(StationID, EventCode, SampleYear, EQ.Latitude, EQ.Longitude, TowType, commonname) %>%
  summarise(n_catch = sum(TotalCatchNum),
            total_wt = sum(TotalCatchWt),
            ind_wt = total_wt/n_catch) %>%
  ungroup() %>%
  group_by(StationID, EventCode, SampleYear, EQ.Latitude, EQ.Longitude, TowType) %>%
  mutate(total_catch = sum(n_catch)) %>%
  mutate(prop_catch = n_catch/total_catch)
```

there's one haul of unusually heavy A0 pollock (20191601068 event 2) but the genetic ids show all but one are indeet pollock so i don't think it'll mess with things if they stay in the data set for adjustment  

okay, there are 74 trawl events that I'm hoping to correct with genetic IDs. let's see how many of those 74 trawls actually had genetic samples collected and analyzed. 

read in gadid catch datafile that i reformatted to better work with in R 
```{r}
genetic_ids <- read.csv("/home/kimberly.ledger/dbo_metabarcoding/data/gadidsamples2010to2019_stationid.csv") %>%
  filter(collection_year %in% c(2017, 2019)) %>%
  select(AlternateID:Comments) %>%
  filter(CommonName != "UNK") %>%
  filter(StationID != "#N/A") %>%
  dplyr::rename(SampleYear = collection_year) %>%
  mutate(StationID = as.numeric(StationID)) %>%
  mutate(EventCode = as.numeric(EventCode))
```

calculate the species proportions for gadids for each unique stationID and eventID
```{r}
gadid_comp <- genetic_ids %>%
  group_by(StationID, EventCode, SampleYear) %>%
  summarize(n_sampled = n(),
            n_AC = sum(CommonName == "Arctic cod"),
            n_WP = sum(CommonName == "Walleye pollock"),
            n_SC = sum(CommonName == "Saffron cod"),
            n_PolC = sum(CommonName == "Polar cod"),
            n_PC = sum(CommonName == "Pacific cod")) %>%
  mutate(prop_AC = n_AC/n_sampled,
         prop_WP = n_WP/n_sampled,
         prop_SC = n_SC/n_sampled,
         prop_PolC = n_PolC/n_sampled,
         prop_PC = n_PC/n_sampled)
```

okay, there are 158 trawl events with genetic info - but some might be events that i don't plan to use or have small sample sizes for reliable adjustments 

test join - putting genetic IDs on the left for now 
```{r}
gadid_join_all <- gadid_comp %>%
  full_join(gadid_age0,  by = c("StationID", "EventCode", "SampleYear")) 
```

sweet. from the look of this table 73/74 trawl events do have genetics samples from them. there are also lots of trawl events that have genetic samples that i don't plan to use 

```{r}
gadid_join_filtered <- gadid_join_all %>%
  filter(!is.na(n_sampled)) %>%  ## removes the one catch data that does not have associated genetic samples (the catch# was small)
  filter(!is.na(n_catch)) %>% ##removes genetic samples that belong to trawls i'm not using
  mutate(num_estimate_AC = prop_AC*n_catch,
         num_estimate_WP = prop_WP*n_catch,
         num_estimate_SC = prop_SC*n_catch,
         num_estimate_PolC = prop_PolC*n_catch,
         num_estimate_PC = prop_PC*n_catch,
         wt_estimate_AC = prop_AC*total_wt,
         wt_estimate_WP = prop_WP*total_wt,
         wt_estimate_SC = prop_SC*total_wt,
         wt_estimate_PolC = prop_PolC*total_wt,
         wt_estimate_PC = prop_PC*total_wt)
```

** should i be estimating proportions of pcod, saffron cod? i removed them from the catch side, maybe they should also not be considered here?? ahh, for now they stay. 


```{r}
gadid_estimates_long <- gadid_join_filtered %>%
  select(c(StationID:SampleYear, num_estimate_AC:wt_estimate_PC)) %>%
  pivot_longer(cols = c(num_estimate_AC:num_estimate_PC), names_to = "commonname", values_to = "n_estimate") %>%
  mutate(commonname = ifelse(commonname == "num_estimate_AC", "Arctic Cod", commonname),
         commonname = ifelse(commonname == "num_estimate_WP", "Pollock", commonname),
         commonname = ifelse(commonname == "num_estimate_SC", "Saffron Cod", commonname),
         commonname = ifelse(commonname == "num_estimate_PolC", "Polar Cod", commonname),
         commonname = ifelse(commonname == "num_estimate_PC", "Pacific Cod", commonname)) %>%
  pivot_longer(cols = c(wt_estimate_AC:wt_estimate_PC), names_to = "commonname2", values_to = "wt_estimate") %>%
  mutate(commonname2 = ifelse(commonname2 == "wt_estimate_AC", "Arctic Cod", commonname2),
         commonname2 = ifelse(commonname2 == "wt_estimate_WP", "Pollock", commonname2),
         commonname2 = ifelse(commonname2 == "wt_estimate_SC", "Saffron Cod", commonname2),
         commonname2 = ifelse(commonname2 == "wt_estimate_PolC", "Polar Cod", commonname2),
         commonname2 = ifelse(commonname2 == "wt_estimate_PC", "Pacific Cod", commonname2)) %>%
  filter(commonname == commonname2) %>%
  filter(n_estimate > 0) %>%
  select(!commonname2)
```


```{r}
gadid_check <- gadid_estimates_long %>%
  full_join(gadid_age0_by_fieldID) %>%
  filter(StationID != "20191601087") %>%  ## no genetic associated with this trawl
  arrange(StationID, EventCode) %>%
  mutate(n_estimate = ifelse(is.na(n_estimate), 0, n_estimate)) %>%
  mutate(wt_estimate = ifelse(is.na(wt_estimate), 0, wt_estimate)) %>%
  mutate(n_catch = ifelse(is.na(n_catch), 0, n_catch)) %>%
  mutate(total_wt = ifelse(is.na(total_wt), 0, total_wt)) %>%
  select(StationID:wt_estimate, n_catch:total_wt) %>%
  mutate(LHSCode = "A0") %>%
  rename(TotalCatchNum = n_catch) %>%
  rename(TotalCatchWt = wt_estimate)
```

### CONTINUE HERE! Need to add a plot for the biomass!!! 


let me plot the original species composition and then the corrected compostions 
```{r}
gadid_to_plot <- gadid_check %>%
  group_by(StationID, EventCode) %>%
  mutate(estimate_sum = sum(n_estimate),
         estimate_prop = n_estimate/estimate_sum) %>%
  mutate(catch_sum = sum(TotalCatchNum),
         catch_prop = TotalCatchNum/catch_sum) %>%
  mutate(StationID = as.factor(StationID)) %>%
  unite("Station_Event", StationID, EventCode, remove = F, sep = "_")


### remember that i filtered to just keep field ids to arctic cod and pollock, so the very few other gadids are not included here. 
field_plot <- gadid_to_plot %>%
  ggplot(aes(x= Station_Event, y = catch_prop, fill = commonname)) +
  geom_bar(stat = "identity") + 
  theme_bw() +
  labs(
    y = "proportion of gadid catch (field IDs)",
    x = "station") +
   theme(axis.text.x = element_text(angle = 45, hjust = 1))

genetic_plot <- gadid_to_plot %>%
  ggplot(aes(x= Station_Event, y = estimate_prop, fill = commonname)) +
  geom_bar(stat = "identity") + 
  theme_bw() +
  labs(
    y = "proportion of gadid catch (genetic IDs)",
    x = "station") +
   theme(axis.text.x = element_text(angle = 45, hjust = 1))

field_plot
genetic_plot
```

alright, now that i have corrected counts/num for age0 gadids I want to fix those in the "fish_catch_filtered" data frame 

```{r}
fish_catch_updated <- fish_catch_filtered %>%
  full_join(gadid_check) %>%
  mutate(TotalCatchNum_corrected = ifelse(is.na(n_estimate), TotalCatchNum, n_estimate)) %>%
  select(StationID, EventCode, SampleYear, commonname, LHSCode, TotalCatchNum, n_estimate, TotalCatchNum_corrected)

plot_gadids <- fish_catch_updated %>%
  filter(!is.na(n_estimate))

ggplot(plot_gadids, aes(x=TotalCatchNum, y=n_estimate, color = commonname)) +
  geom_point() + 
  theme_bw() +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black")

## remove some of the large count data trawls to visualize 
plot_gadids %>%
  filter(TotalCatchNum < 20000) %>%
  ggplot(aes(x=TotalCatchNum, y=n_estimate, color = commonname)) +
  geom_point() + 
  theme_bw() +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black")
```

since i could not retain lat/long metadata during the joining of the genetic data, let me get that info back and then make some plots
```{r}
station_event_metadata <- fish_catch_filtered %>%
  select(StationID:Gear.Depth) %>%
  unique()
```

```{r}
fish_catch_updated <- fish_catch_updated %>%
  left_join(station_event_metadata)
```

even though Effort metric is present for most trawls, it seems hard to compare counts in a quantitative way over years. - so i'm not even going to try and do across year abundance or biomass comparisons for single species. but how about presence/absence for gadids over time? that seems reasonable. 

load libraries
```{r}
library(rnaturalearth)
library(rnaturalearthdata)
world <- ne_countries(scale = "medium", returnclass = "sf")
```


## arctic cod detections
```{r}
binary_AC <- temp %>%
  filter(commonname == "Arctic Cod") %>%
  mutate(pres_fieldID = ifelse(TotalCatchNum > 0, 1, 0),
         pres_geneticID = ifelse(TotalCatchNum_corrected > 0, 1, 0))
```

```{r}
min_lat <- min(binary_AC$EQ.Latitude, na.rm = T)
max_lat <- max(binary_AC$EQ.Latitude, na.rm = T)

min_lon <- min(binary_AC$EQ.Longitude, na.rm = T)
max_lon <- max(binary_AC$EQ.Longitude, na.rm = T)
  
ggplot(data = world) +
  geom_sf() +
  geom_point(data = binary_AC, aes(x=EQ.Longitude, y=EQ.Latitude, color = as.factor(pres_fieldID))) +
  facet_grid(~SampleYear) + 
  coord_sf(xlim = c(min_lon-2, max_lon+2), ylim = c(min_lat-1, max_lat+1), expand = FALSE) +
  theme_bw() +xlab("Longitude") +ylab("Latitude")+
  labs(color = "") +
  theme(axis.text.x = element_text(angle = 90))

ggplot(data = world) +
  geom_sf() +
  geom_point(data = binary_AC, aes(x=EQ.Longitude, y=EQ.Latitude, color = as.factor(pres_geneticID))) +
  facet_grid(~SampleYear) + 
  coord_sf(xlim = c(min_lon-2, max_lon+2), ylim = c(min_lat-1, max_lat+1), expand = FALSE) +
  theme_bw() +xlab("Longitude") +ylab("Latitude")+
  labs(color = "") +
  theme(axis.text.x = element_text(angle = 90))
```

```{r}
binary_WP <- temp %>%
  filter(commonname == "Pollock") %>%
  mutate(pres_fieldID = ifelse(TotalCatchNum > 0, 1, 0),
         pres_geneticID = ifelse(TotalCatchNum_corrected > 0, 1, 0))
```

```{r}
min_lat <- min(binary_WP$EQ.Latitude, na.rm = T)
max_lat <- max(binary_WP$EQ.Latitude, na.rm = T)

min_lon <- min(binary_WP$EQ.Longitude, na.rm = T)
max_lon <- max(binary_WP$EQ.Longitude, na.rm = T)
  
ggplot(data = world) +
  geom_sf() +
  geom_point(data = binary_WP, aes(x=EQ.Longitude, y=EQ.Latitude, color = as.factor(pres_fieldID))) +
  facet_grid(~SampleYear) + 
  coord_sf(xlim = c(min_lon-2, max_lon+2), ylim = c(min_lat-1, max_lat+1), expand = FALSE) +
  scale_color_manual(values = c("0" = "grey", "1" = "red")) + 
  theme_bw() +xlab("Longitude") +ylab("Latitude")+
  labs(color = "") +
  theme(axis.text.x = element_text(angle = 90))

ggplot(data = world) +
  geom_sf() +
  geom_point(data = binary_WP, aes(x=EQ.Longitude, y=EQ.Latitude, color = as.factor(pres_geneticID))) +
  facet_grid(~SampleYear) + 
  coord_sf(xlim = c(min_lon-2, max_lon+2), ylim = c(min_lat-1, max_lat+1), expand = FALSE) +
  scale_color_manual(values = c("0" = "grey", "1" = "red")) + 
  theme_bw() +xlab("Longitude") +ylab("Latitude")+
  labs(color = "") +
  theme(axis.text.x = element_text(angle = 90))
```


alright what i really want to do is community multivariate stats on the corrected counts. (well maybe it should be biomass, but that'll take some back tracking to get to work.)

make wide species table and associated metadata table 

```{r}
temp2 <- temp %>%
  unite("Station_Event", StationID, EventCode, sep = "_", remove = F) %>%
  group_by(Station_Event, commonname) %>%
  summarize(TotalCatch = sum(TotalCatchNum_corrected)) %>%                               ## i'm adding across lifestages here. might be better to deal with biomass
  pivot_wider(names_from = "commonname", values_from = "TotalCatch", values_fill = 0)
```

get full metadata in the same format 
```{r}
station_meta <- read.csv("/home/kimberly.ledger/dbo_metabarcoding/data/Kim_Arctic_11.1.24.csv") %>%
  unite("Station_Event", StationID, EventCode, sep = "_", remove = F) %>%
  select(c(Station_Event:Gear.Depth, SurfaceTemperature:Bottom_CHLA)) %>%
  unique() %>%
  mutate(across(everything(), ~ ifelse(gsub("#N/A", NA, .) == "NA", NA, .)),
         SurfaceTemperature = ifelse(SurfaceTemperature == 0, NA, SurfaceTemperature),
         SurfaceSalinity = ifelse(SurfaceSalinity == 0, NA, SurfaceSalinity),
         Surface_CHLA = ifelse(Surface_CHLA == 0, NA, Surface_CHLA),
         BottomTemperature = ifelse(BottomTemperature == 0, NA, BottomTemperature),
         BottomSalinity = ifelse(BottomSalinity == 0, NA, BottomSalinity),
         Bottom_CHLA = ifelse(Bottom_CHLA == 0, NA, Bottom_CHLA))
```

hmm quite a bit of 0's and "#NA" for temp, salinity, chloro... 


```{r}
temp_w_meta <- temp2 %>%
  left_join(station_meta)

temp_w_meta
```

separate now 
```{r}
taxa_table <- temp_w_meta[,c(1:76)] %>%
  mutate(across(everything(), ~ ifelse(is.na(.), 0, .)))

meta_station <- temp_w_meta[,c(1,77:93)] %>%
  mutate(SurfaceTemperature = as.numeric(SurfaceTemperature),
         SurfaceSalinity = as.numeric(SurfaceSalinity),
         Surface_CHLA = as.numeric(Surface_CHLA),
         BottomTemperature = as.numeric(BottomTemperature),
         BottomSalinity = as.numeric(BottomSalinity),
         Bottom_CHLA = as.numeric(Bottom_CHLA))


rowSums(taxa_table[,-1])
```

make some quick plots of correlations among variables 
```{r}
cor_matrix <- cor(meta_table[,c(5,6,13:18)], use = "pairwise.complete.obs")
print(cor_matrix)

library(ggcorrplot)
ggcorrplot(cor_matrix, lab = TRUE)
```


set up the wide dataframes for multivariate analyses
```{r}
count_df_wide <- taxa_table 

binary_df_wide <- taxa_table %>%
   mutate(across(everything(), ~ ifelse(. > 0, 1, .)))
```

## test for differences in communities between lat/long/year using PERMANOVA 
```{r}
binary_dist <- vegdist(binary_df_wide[,-1], method = "jaccard")

# Run PERMANOVA with latitude as the predictor
binary_lat <- adonis2(binary_dist ~ meta_station$EQ.Latitude, permutations = 999)
binary_lat
binary_year <- adonis2(binary_dist ~ meta_station$SampleYear, permutations = 999)
binary_year
#binary_temp_surface <- adonis2(binary_dist ~ meta_station$SurfaceTemperature, permutations = 999)    ## there's some missing data so this doesn't work
#binary_temp_surface
#binary_temp_subsurface <- adonis2(binary_dist ~ meta_station$BottomTemperature, permutations = 999)
#binary_temp_subsurface
#binary_salinity_surface <- adonis2(binary_dist ~ meta_station$SurfaceSalinity, permutations = 999)
#binary_salinity_surface
#binary_salinity_subsurface <- adonis2(binary_dist ~ meta_station$BottomSalinity, permutations = 999)
#binary_salinity_subsurface
```


## test for differences in communities between lat/long/year using PERMANOVA 
```{r}
count_dist <- vegdist(count_df_wide[,-1], method = "bray")

# Run PERMANOVA with latitude as the predictor
count_lat <- adonis2(count_dist ~ meta_station$EQ.Latitude, permutations = 999)
count_lat
count_year <- adonis2(count_dist ~ meta_station$SampleYear, permutations = 999)
count_year
#count_temp_surface <- adonis2(count_dist ~ meta_station$SurfaceTemperature, permutations = 999)    ## there's some missing data so this doesn't work
#count_temp_surface
#count_temp_subsurface <- adonis2(count_dist ~ meta_station$BottomTemperature, permutations = 999)
#count_temp_subsurface
#count_salinity_surface <- adonis2(count_dist ~ meta_station$SurfaceSalinity, permutations = 999)
#count_salinity_surface
#count_salinity_subsurface <- adonis2(count_dist ~ meta_station$BottomSalinity, permutations = 999)
#count_salinity_subsurface
```

visualize with NMDS - binary data 
```{r}
binary_dist <- vegdist(binary_df_wide[,-1], method = "jaccard")
binary_mds <- metaMDS(binary_dist)

NMS_data <- binary_mds

#create vectors with the NMS attributes
NMS_coordinates<-vegan::scores(NMS_data,display="sites")
NMS_axes<-as.data.frame(NMS_coordinates)
NMS_scores<-vegan::scores(NMS_data,display="species")

for_ploting<-as.data.frame(cbind(NMS_coordinates,meta_station))

nmds.plot <- ggplot(for_ploting, aes(x=NMDS1, y=NMDS2))+ #sets up the plot
  geom_point(aes(NMDS1, NMDS2, colour = EQ.Latitude), size = 2)+ #adds site points to plot, shape determined by year, colour determined by location
  coord_fixed()+
  theme_classic()+ 
  theme(panel.background = element_rect(fill = NA, colour = "black", size = 1, linetype = "solid"))+
  #labs(colour = "Latitude", shape = "Year", title = "by latitude") + # add legend labels for Station
  theme(legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.title = element_text(size = 12), 
        axis.text = element_text(size = 10)) #+ # add legend at right of plot
nmds.plot


nmds.plot <- ggplot(for_ploting, aes(x=NMDS1, y=NMDS2))+ #sets up the plot
  geom_point(aes(NMDS1, NMDS2, colour = as.factor(SampleYear)), size = 2)+ #adds site points to plot, shape determined by year, colour determined by location
  coord_fixed()+
  theme_classic()+ 
  theme(panel.background = element_rect(fill = NA, colour = "black", size = 1, linetype = "solid"))+
  #labs(colour = "Latitude", shape = "Year", title = "by latitude") + # add legend labels for Station
  theme(legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.title = element_text(size = 12), 
        axis.text = element_text(size = 10)) #+ # add legend at right of plot
nmds.plot
```

visualize with NMDS - count data 
```{r}
count_dist <- vegdist(count_df_wide[,-1], method = "bray")
count_mds <- metaMDS(count_dist)

NMS_data <- count_mds

#create vectors with the NMS attributes
NMS_coordinates<-vegan::scores(NMS_data,display="sites")
NMS_axes<-as.data.frame(NMS_coordinates)
NMS_scores<-vegan::scores(NMS_data,display="species")

for_ploting<-as.data.frame(cbind(NMS_coordinates,meta_station))

nmds.plot <- ggplot(for_ploting, aes(x=NMDS1, y=NMDS2))+ #sets up the plot
  geom_point(aes(NMDS1, NMDS2, colour = EQ.Latitude), size = 2)+ #adds site points to plot, shape determined by year, colour determined by location
  coord_fixed()+
  theme_classic()+ 
  theme(panel.background = element_rect(fill = NA, colour = "black", size = 1, linetype = "solid"))+
  #labs(colour = "Latitude", shape = "Year", title = "by latitude") + # add legend labels for Station
  theme(legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.title = element_text(size = 12), 
        axis.text = element_text(size = 10)) #+ # add legend at right of plot
nmds.plot


nmds.plot <- ggplot(for_ploting, aes(x=NMDS1, y=NMDS2))+ #sets up the plot
  geom_point(aes(NMDS1, NMDS2, colour = as.factor(SampleYear)), size = 2)+ #adds site points to plot, shape determined by year, colour determined by location
  coord_fixed()+
  theme_classic()+ 
  theme(panel.background = element_rect(fill = NA, colour = "black", size = 1, linetype = "solid"))+
  #labs(colour = "Latitude", shape = "Year", title = "by latitude") + # add legend labels for Station
  theme(legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.title = element_text(size = 12), 
        axis.text = element_text(size = 10)) #+ # add legend at right of plot
nmds.plot
```


let me try a distance-based redundancy analysis (dbRDA) - USING BINARY! 
```{r}
# Fit the dbRDA model - using capscale() - constrained analysis of principal coordinates

rda_binary <- capscale(binary_df_wide[,-1] ~ 
                        meta_station$EQ.Latitude + 
                        as.factor(meta_station$SampleYear), # + 
                         #meta_station$SurfaceTemperature + 
                         #meta_station$BottomTemperature + 
                         #meta_station$salinity_at_surface + 
                         #meta_station$salinity_at_subsurface,
                       distance = "jaccard")

anova_terms <- anova(rda_binary, by = "terms", permutations = 999)
anova_terms 

summary(rda_binary)

# Assuming capscale_model is already defined
eigenvalues <- rda_binary$CA$eig
total_inertia <- sum(eigenvalues)

# Calculate proportion explained for CAP1 and CAP2
proportion_variance <- eigenvalues / total_inertia * 100

## First use the regular plot option to get a feel for the data
#plot(rda_index, scaling = 2, choices = c(1,2))
#plot(rda_index, scaling = 2, choices = c(1,3))

# CAP1 = latitude, CAP2 = year, CAP3 = depth (CAP3 changes when adding in temp and salinity to the model)

# Extract site and species scores
site_scores <- as.data.frame(vegan::scores(rda_binary, display = "sites", choices = 1:3))
#site_scores <- as.data.frame(rda_index$CCA$u[, 1:3])
site_scores$Sample <- rownames(site_scores)  # Add sample names

species_scores <- as.data.frame(vegan::scores(rda_binary, display = "species", choices = 1:3))
#species_scores <- as.data.frame(rda_index$CCA$v[, 1:3])
species_scores$Species <- rownames(species_scores)  # Add species names

# Extract biplot arrows (for explanatory variables)
biplot_arrows <- as.data.frame(vegan::scores(rda_binary, display = "bp", choices = 1:3))
#biplot_arrows <- as.data.frame(rda_index$CCA$biplot[, 1:3])
biplot_arrows$variable <- rownames(biplot_arrows)

biplot_arrows <- biplot_arrows %>%
  mutate(variable = ifelse(variable == "meta_station$EQ.Latitude", "latitude", variable),
         variable = ifelse(variable == "as.factor(meta_station$SampleYear)2013", "2013", variable),
         variable = ifelse(variable == "as.factor(meta_station$SampleYear)2017", "2017", variable),
         variable = ifelse(variable == "as.factor(meta_station$SampleYear)2019", "2019", variable)) #,
         #variable = ifelse(variable == "meta_station$temp_C_at_surface", "surface temp", variable),
         #variable = ifelse(variable == "meta_station$temp_C_at_subsurface", "subsurface temp", variable),
         #variable = ifelse(variable == "meta_station$salinity_at_surface", "surface salinity", variable),
         #variable = ifelse(variable == "meta_station$salinity_at_subsurface", "subsurface salinity", variable))

## Plot CAP1 vs CAP2 - color sites by latitude
plot_lat <- ggplot() +
  # Plot site scores
  geom_point(data = site_scores, aes(x = CAP1, y = CAP2, color = meta_station$EQ.Latitude), size = 3) +
  #geom_text_repel(data = site_scores, aes(x = CAP1, y = CAP2, label = Sample), size = 4) +
  scale_color_viridis(option = "cividis",  direction = -1) +
  
  # Plot species scores
  geom_point(data = species_scores, aes(x = CAP1, y = CAP2), color = "red", size = 2) +
  geom_text_repel(data = species_scores, aes(x = CAP1, y = CAP2, label = Species), color = "red", size = 2) +
  
  # Plot arrows
  geom_segment(data = biplot_arrows, aes(x = 0, y = 0, xend = CAP1, yend = CAP2), 
               arrow = arrow(length = unit(0.3, "cm")), color = "black") + # Plot biplot arrows
  geom_text(data = biplot_arrows, aes(x = CAP1 * 1.1, y = CAP2 * 1.1, label = variable), color = "black") + # Label arrows
  
  # Add labels and theme
  labs(title = "CAP Plot", 
       x = paste("CAP1 (", round(proportion_variance[1], 2), "% variance explained)", sep = ""), 
       y = paste("CAP2 (", round(proportion_variance[2], 2), "% variance explained)", sep = ""),
       color = "latitude") +
  theme_minimal() #+
  #theme(legend.position = "none")

plot_lat

## Plot CAP1 vs CAP2 - color sites by year
plot_year <- ggplot() +
  # Plot site scores
  geom_point(data = site_scores, aes(x = CAP1, y = CAP2, color = as.factor(meta_station$SampleYear)), size = 3) +
  #geom_text_repel(data = site_scores, aes(x = CAP1, y = CAP2, label = Sample), size = 4) +
  
  # Plot species scores
  geom_point(data = species_scores, aes(x = CAP1, y = CAP2), color = "black", size = 2) +
  geom_text_repel(data = species_scores, aes(x = CAP1, y = CAP2, label = Species), color = "black", size = 2) +
  
  # Plot arrows
  geom_segment(data = biplot_arrows, aes(x = 0, y = 0, xend = CAP1, yend = CAP2), 
               arrow = arrow(length = unit(0.3, "cm")), color = "black") + # Plot biplot arrows
  geom_text(data = biplot_arrows, aes(x = CAP1 * 1.1, y = CAP2 * 1.1, label = variable), color = "black") + # Label arrows
  
  # Add labels and theme
  labs(title = "CAP Plot", 
       x = paste("CAP1 (", round(proportion_variance[1], 2), "% variance explained)", sep = ""), 
       y = paste("CAP2 (", round(proportion_variance[2], 2), "% variance explained)", sep = ""),  
       color = "year") +
  theme_minimal() #+
  #theme(legend.position = "none")

plot_year

## Plot CAP1 vs CAP3 - color sites by temp
plot_temp <- ggplot() +
  # Plot site scores
  geom_point(data = site_scores, aes(x = CAP1, y = CAP3, color = meta_station$temp_C_at_subsurface), size = 3) +
  #geom_text_repel(data = site_scores, aes(x = CAP1, y = CAP3, label = Sample), size = 4) +
  scale_colour_viridis(option = "C", direction = -1) + 
  
  # Plot species scores
  geom_point(data = species_scores, aes(x = CAP1, y = CAP3), color = "black", size = 2) +
  geom_text_repel(data = species_scores, aes(x = CAP1, y = CAP3, label = Species), color = "black", size = 2) +
  
  # Plot arrows
  geom_segment(data = biplot_arrows, aes(x = 0, y = 0, xend = CAP1, yend = CAP3), 
               arrow = arrow(length = unit(0.3, "cm")), color = "black") + # Plot biplot arrows
  geom_text(data = biplot_arrows, aes(x = CAP1 * 1.1, y = CAP3 * 1.1, label = variable), color = "black") + # Label arrows
  
  # Add labels and theme
  labs(title = "CAP Plot", 
       x = paste("CAP1 (", round(proportion_variance[1], 2), "% variance explained)", sep = ""), 
       y = paste("CAP3 (", round(proportion_variance[3], 2), "% variance explained)", sep = ""), 
       color = "subsurface temperature") +
  theme_minimal() #+
  #theme(legend.position = "none")

plot_temp
```









### stopped updated code here



okay, for multivariate analyses i can't have any empty rows (stations with no fish) so i'll need to remove those 
```{r}
fish_wide_filtered <- fish_wide_all_stations %>%
  filter(rowSums(select(., 8:ncol(.)), na.rm = TRUE) != 0)            

fish_totalcatchnum <- fish_wide_filtered[,-c(1:7)] 

fish_binary <- fish_wide_filtered[,-c(1:7)] %>%
   mutate(across(everything(), ~ ifelse(is.na(.), 0, ifelse(. > 0, 1, 0))))
  
fish_meta <- fish_wide_filtered[,c(1:7)]  

binary_dist<- vegdist(fish_binary, method = "jaccard")

# Run PERMANOVA with latitude as the predictor
binary_lat <- adonis2(binary_dist ~ fish_meta$eq_latitude, permutations = 999)
binary_lat
binary_year <- adonis2(binary_dist ~ as.factor(fish_meta$sampleyear), permutations = 999)
binary_year
```

check dispersion for sampling year
```{r}
dispersion <- betadisper(binary_dist, as.factor(fish_meta$sampleyear))

# Step 2: Perform a permutation test for multivariate homogeneity of group dispersions (PERMDISP)
dispersion_test <- permutest(dispersion, permutations = 999)

# Step 3: View the results of the test
print(dispersion_test)

# Step 4: Optionally, visualize the distances to group centroids
plot(dispersion)
boxplot(dispersion, main = "Group Dispersion by Year")
```


# Fit the dbRDA model - using capscale() - constrained analysis of principal coordinates
```{r}
rda_index <- capscale(fish_binary ~ fish_meta$eq_latitude + as.factor(fish_meta$sampleyear), distance = "jaccard")  ## need to change variable name at somepoint to avoid confusion...

anova_terms <- anova(rda_index, by = "terms", permutations = 999)
anova_terms 

summary(rda_index)

# Assuming capscale_model is already defined
eigenvalues <- rda_index$CA$eig
total_inertia <- sum(eigenvalues)

# Calculate proportion explained for CAP1 and CAP2
proportion_variance <- eigenvalues / total_inertia * 100

# First use the regular plot option to get a feel for the data
plot(rda_index, scaling = 2, choices = c(1,2))
#plot(rda_index, scaling = 2, choices = c(1,3))


# Extract site and species scores
site_scores <- as.data.frame(vegan::scores(rda_index, display = "sites", choices = 1:3))
#site_scores <- as.data.frame(rda_index$CCA$u[, 1:3])
site_scores$Sample <- rownames(site_scores)  # Add sample names

species_scores <- as.data.frame(vegan::scores(rda_index, display = "species", choices = 1:3))
#species_scores <- as.data.frame(rda_index$CCA$v[, 1:3])
species_scores$Species <- rownames(species_scores)  # Add species names

# Extract biplot arrows (for explanatory variables)
biplot_arrows <- as.data.frame(vegan::scores(rda_index, display = "bp", choices = 1:3))
#biplot_arrows <- as.data.frame(rda_index$CCA$biplot[, 1:3])
biplot_arrows$variable <- rownames(biplot_arrows)

biplot_arrows <- biplot_arrows %>%
  mutate(variable = ifelse(variable == "fish_meta$eq_latitude", "latitude", variable),
         #variable = ifelse(variable == "meta_for_nmds$depth", "depth", variable),
         variable = ifelse(variable == "as.factor(fish_meta$sampleyear)2013", "year_2013", variable),
         variable = ifelse(variable == "as.factor(fish_meta$sampleyear)2017", "year_2017", variable),
         variable = ifelse(variable == "as.factor(fish_meta$sampleyear)2019", "year_2019", variable)) #,
         #variable = ifelse(variable == "meta_for_nmds$temp_C", "temperature", variable),
         #variable = ifelse(variable == "meta_for_nmds$salinity", "salinity", variable))

## Plot CAP1 vs CAP2 - color sites by latitude
plot_lat <- ggplot() +
  # Plot site scores
  geom_point(data = site_scores, aes(x = CAP1, y = CAP2, color = fish_meta$eq_latitude), size = 3) +
  #geom_text_repel(data = site_scores, aes(x = CAP1, y = CAP2, label = Sample), size = 4) +
  scale_color_viridis(option = "cividis",  direction = -1) +
  
  # Plot species scores
  geom_point(data = species_scores, aes(x = CAP1, y = CAP2), color = "red", size = 2) +
  geom_text_repel(data = species_scores, aes(x = CAP1, y = CAP2, label = Species), color = "red", size = 2) +
  
  # Plot arrows
  geom_segment(data = biplot_arrows, aes(x = 0, y = 0, xend = CAP1, yend = CAP2), 
               arrow = arrow(length = unit(0.3, "cm")), color = "black") + # Plot biplot arrows
  geom_text(data = biplot_arrows, aes(x = CAP1 * 1.1, y = CAP2 * 1.1, label = variable), color = "black") + # Label arrows
  
  # Add labels and theme
  labs(title = "CAP Plot", 
       x = paste("CAP1 (", round(proportion_variance[1], 2), "% variance explained)", sep = ""), 
       y = paste("CAP2 (", round(proportion_variance[2], 2), "% variance explained)", sep = ""),
       color = "latitude") +
  theme_minimal() #+
  #theme(legend.position = "none")


## Plot CAP1 vs CAP2 - color sites by year
plot_year <- ggplot() +
  # Plot site scores
  geom_point(data = site_scores, aes(x = CAP1, y = CAP2, color = as.factor(fish_meta$sampleyear)), size = 3) +
  #geom_text_repel(data = site_scores, aes(x = CAP1, y = CAP2, label = Sample), size = 4) +
  
  # Plot species scores
  geom_point(data = species_scores, aes(x = CAP1, y = CAP2), color = "black", size = 2) +
  geom_text_repel(data = species_scores, aes(x = CAP1, y = CAP2, label = Species), color = "black", size = 2) +
  
  # Plot arrows
  geom_segment(data = biplot_arrows, aes(x = 0, y = 0, xend = CAP1, yend = CAP2), 
               arrow = arrow(length = unit(0.3, "cm")), color = "black") + # Plot biplot arrows
  geom_text(data = biplot_arrows, aes(x = CAP1 * 1.1, y = CAP2 * 1.1, label = variable), color = "black") + # Label arrows
  
  # Add labels and theme
  labs(title = "CAP Plot", 
       x = paste("CAP1 (", round(proportion_variance[1], 2), "% variance explained)", sep = ""), 
       y = paste("CAP2 (", round(proportion_variance[2], 2), "% variance explained)", sep = ""),  
       color = "year") +
  theme_minimal() #+
  #theme(legend.position = "none")

plot_lat
plot_year
```


hierarchial cluster analysis 
```{r}
#let's just go with one year of data for now...
sub_2013 <- fish_wide_filtered %>%
  filter(sampleyear == 2013)

meta_2013 <- sub_2013[,c(1:7)]
fish_2013 <- sub_2013[,-c(1:7)]

dist_2013 <- vegdist(fish_2013, method = "jaccard")

# Cluster Dendrogram
hc <- hclust(dist_2013, method = "ward.D2")
plot(hc, labels = meta_2013$stationid)

#groups <- cutree(hc, k = 2)   ## just starting with k=3
#adonis2(dist_2013 ~ groups)

# Number of clusters to evaluate
k.max <- 10
wss <- numeric(k.max)

# Loop through k values to calculate WSS
for (k in 1:k.max) {
  # Cut the dendrogram into k groups
  cluster_assignment <- cutree(hc, k)
  
  # Calculate total within-cluster sum of squares
  wss[k] <- sum(sapply(unique(cluster_assignment), function(cluster) {
    sum((dist(fish_2013[cluster_assignment == cluster, ])^2))  # Sum of squares for each cluster
  }))
}

# Plot the elbow curve
plot(1:k.max, wss, type = "b", pch = 19, frame = FALSE, 
     xlab = "Number of Clusters (k)", 
     ylab = "Total Within-Cluster Sum of Squares (WSS)",
     main = "Elbow Method for Optimal k")

groups <- cutree(hc, k = 4)   ## just starting with k=3
adonis2(dist_2013 ~ groups)

plot(hc, labels = meta_2013$stationid)
rect.hclust(hc, k = 4, border = "red")  # You can specify color here


#library(ggdendro)
#ggdendrogram(hc)

library(dendextend)
# Create a dendrogram object
dend <- as.dendrogram(hc)
# Create a color palette (e.g., blue to red gradient based on latitude)
latitudes <- meta_2013$eq_latitude
color_palette <- colorRampPalette(c("blue", "red"))(length(latitudes))
# Map latitudes to colors
latitude_colors <- color_palette[rank(latitudes)]  # Rank the latitudes and assign colors
# Assign these colors to the labels (tips) of the dendrogram
labels_colors(dend) <- latitude_colors
# Plot the dendrogram with colored tips based on latitude
plot(dend, main = "Dendrogram with Tips Colored by Latitude")
rect.hclust(hc, k = 4, border = "red")  # You can specify color here

```

okay, not all groups are predicted by latitude 

run similarity percentages (SIMPER) analysis using vegan
```{r}
simper_out <- simper(fish_2013, group = groups)
simper_out

temp <- summary(simper_out)

# take output out into a single dataframe 
# Initialize an empty data frame
combined_df <- data.frame()
# Loop through the list to combine data frames
for (group_name in names(simper_out)) {
  # Extract the current data frame
  temp_df <- simper_out[[group_name]]
  
  # Add a new column with the group name
  temp_df$Group <- group_name
  
  # Combine with the main data frame
  combined_df <- bind_rows(combined_df, temp_df)
}

# what species have p < 0.05
simper_sign <- combined_df %>%
  filter(average > 0) %>%
  filter(p <= 0.05)
```

arctic cod and herring are driving station clusters 

now i want to plot those cluster onto a map to visualize any location patterns 
```{r}
meta_2013$group <- groups
```

load libraries
```{r}
library(rnaturalearth)
library(rnaturalearthdata)
world <- ne_countries(scale = "medium", returnclass = "sf")
```

```{r}
min_lat <- min(meta_2013$eq_latitude, na.rm = T)
max_lat <- max(meta_2013$eq_latitude, na.rm = T)

min_lon <- min(meta_2013$eq_longitude, na.rm = T)
max_lon <- max(meta_2013$eq_longitude, na.rm = T)

meta_2013$group <- as.factor(meta_2013$group)
  
ggplot(data = world) +
  geom_sf() +
  geom_point(data = meta_2013, aes(x=eq_longitude, y=eq_latitude, color = group)) +
  #scale_color_gradient(low = "blue", high = "red", na.value = "black") +  # Color gradient for counts
  #facet_grid(collection_year~CommonName) + 
  coord_sf(xlim = c(min_lon-2, max_lon+2), ylim = c(min_lat-1, max_lat+1), expand = FALSE) +
  theme_bw() +xlab("Longitude") +ylab("Latitude")+
  labs(color = "count") +
  theme(axis.text.x = element_text(angle = 90))
```


indicator species
```{r}
library(labdsv)

# Perform indicator species analysis
indicator_year <- indval(fish_binary, fish_meta$sampleyear, perm = 999)
summary(indicator_year)
```

```{r}
# this only works for categorical variables, so let me make some dummy groups for this 
binned_lat <- cut(fish_meta$eq_latitude, breaks = quantile(fish_meta$eq_latitude, probs = seq(0,1,0.25)), include.lowest = TRUE)

#meta_for_nmds <- meta_for_nmds %>%
#  mutate(latitude_group = ifelse(latitude <= 65, "low", NA),
#         latitude_group = ifelse(latitude > 65 & latitude < 71, "middle", latitude_group),
#         latitude_group = ifelse(latitude >= 71, "high", latitude_group))

#indicator_latitude<- indval(index_df_wide[,-1], meta_for_nmds$latitude_group, perm = 999)
indicator_latitude<- indval(fish_binary, binned_lat, perm = 999)
indicator_latitude
summary(indicator_latitude)
```

taxa richness (fish only) by year and latitude
```{r}
taxon_table_with_year_and_lat <- cbind(fish_meta$sampleyear, fish_meta$eq_latitude, fish_binary)
colnames(taxon_table_with_year_and_lat)[1] <- "year"  # Rename the year column
colnames(taxon_table_with_year_and_lat)[2] <- "latitude"
#colnames(taxon_table_with_year_and_lat)[3] <- "depth"
#colnames(taxon_table_with_year_and_lat)[4] <- "temp"

# Exclude the "year" column and calculate species richness using rowSums
taxon_table_with_year_and_lat <- taxon_table_with_year_and_lat %>%
  mutate(richness = rowSums(select(., -c(year,latitude)) > 0))

ggplot(taxon_table_with_year_and_lat, aes(x = latitude, y = richness, color = as.factor(year))) +
  geom_point() +   # Scatter plot points
  geom_smooth(method = "loess", se = TRUE) +  # Smoothed line (loess curve)
  labs(x = "Latitude", y = "Taxa Richness", title = "Species Richness by Latitude", color = "latitude") +
  theme_minimal()                 # Apply a clean minimal theme

```

much higher spp richness ~70N in 2017 than in other years 
- need to check how taxa were id'd - ie make sure level of classifications is consistent over the years

check out what's going on with arctic cod and pollock by latitude 
disclaimer:  i don't believe this version of the data has been corrected for the mis-id'd cod

```{r}
fish_wide_all_stations <- fish_wide_all_stations %>%
  mutate(lat_bin = ifelse(eq_latitude <= 64, "<64", NA),
         lat_bin = ifelse(eq_latitude > 64 & eq_latitude <= 66, "64-66", lat_bin),
         lat_bin = ifelse(eq_latitude > 66 & eq_latitude <= 68, "66-68", lat_bin),
         lat_bin = ifelse(eq_latitude > 68 & eq_latitude <= 70, "68-70", lat_bin),
         lat_bin = ifelse(eq_latitude > 70 & eq_latitude <= 72, "70-72", lat_bin),
         lat_bin = ifelse(eq_latitude > 72, ">72", lat_bin))

haul_summary <- fish_wide_all_stations %>%
  group_by(sampleyear, lat_bin) %>%
  summarise(unique_hauls = n(),
            AC = sum(`Boreogadus saida` > 0),
            WP = sum(`Gadus chalcogrammus` > 0),
            prop_AC = AC/unique_hauls,
            prop_WP = WP/unique_hauls)

my_order <- c("<64", "64-66", "66-68", "68-70", "70-72", ">72")

haul_summary$lat_bin <- factor(haul_summary$lat_bin, levels = my_order)

df_prop_w_pos <- haul_summary %>%
  select(sampleyear, lat_bin, prop_AC, prop_WP) %>% #  , prop_PC, prop_SC, prop_PolC) %>%
  pivot_longer(cols = c(3:4), values_to = "prop", names_to = "taxon") %>%
  mutate(CommonName = ifelse(taxon == "prop_AC", "Arctic cod", NA),
         CommonName = ifelse(taxon == "prop_WP", "Walleye pollock", CommonName)) #,
         #CommonName = ifelse(taxon == "prop_PC", "Pacific cod", CommonName),
         #CommonName = ifelse(taxon == "prop_SC", "Saffron cod", CommonName),
         #CommonName = ifelse(taxon == "prop_PolC", "Polar cod", CommonName))

df_prop_w_pos %>%
  ggplot(aes(x=CommonName, y=lat_bin, fill = prop)) +
  geom_tile() + 
  scale_fill_gradient(low = "lightblue", high = "darkblue") +  # Adjust color scale as needed
  #geom_text(data = samp_size, aes(x=lat_bin, y = total_samples + 2, label = total_samples)) +
  facet_grid(~sampleyear) + 
  labs(title = "Heatmap of Proportion of Hauls with Detection",
       x = "Species",
       y = "Latitude",
       fill = "Proportion of Hauls with Detection") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for readability  

```

okay, general trends are there but the data is very messy. 
